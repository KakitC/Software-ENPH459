"""
ipsRaster.py
Image processing functions for the raster image engraving control path.

pic: actual picture
px: pixel position
pix: pixel value
"""
from __future__ import division

__author__ = 'kakit'

from PIL import Image, ImageFilter, ImageStat, ImageEnhance, ImageChops, \
    ImageOps
import numpy as np


def raster_dither(in_file, scaling=1, pad=(0, 0)):
    """ Convert an image to dithered greyscale, and pad it to the position
    given to ready for sending to the laser as a power/speed bitmap.

    Raises an IOError if image file could not be opened.

    :param in_file: Relative file path and name of input image
    :type: string
    :param scaling: Dots per mm setting
    :type: double
    :param pad: Set datum position of top-left of image engraving in mm
    :type: (double, double)
    :return: Image converted to raster bitmap
    """
    # Get image, convert
    # Resize
    # Pad
    # Output

    # Main processing blocks, filters
    with Image.open(in_file) as pic:
        pic = pic.convert(mode="L")  # To greyscale

        edges = pic.filter(ImageFilter.CONTOUR)  # Pick out edges
        edges = edges.filter(ImageFilter.SMOOTH_MORE)  # Smooth noise

        pic = pic.filter(ImageFilter.SMOOTH_MORE)  # Smooth noise in original

        # Brightness leveling for dark images
        brightness = ImageStat.Stat(pic).mean
        if brightness[0] < 100:
            pic = ImageEnhance.Brightness(pic).enhance(1.75)
        elif brightness[0] < 120:
            pic = ImageEnhance.Brightness(pic).enhance(1.2)

        pic = ImageChops.multiply(pic, edges)  # Recombine edges for crispness
        pic = pic.convert("1")  # Uses Floyd-Steinberg dithering by default

        # Pad out from corner
        if pad == (0, 0):
            big_pic = Image.new("1", tuple([pic.size[i] + int(pad[i]*scaling) for i
                                            in [0,1]]), color=1)
            big_pic.paste(pic, pad)
            pic = big_pic

        pic = pic.convert("L")  # Convert back to 8bit greyscale (for laser)
        return pic


def gen_gcode(pic, scaling, filename):
    """ Generate a G-code file to engrave the picture, and save the text.

    Update all HardwareManager settings before generating G-code.
    Does not execute the commands, nor sets the HardwareManager las_mask.

    Raises IOError if file could not be opened/written to.

    :param pic: Image to engrave
    :type: PIL.Image.Image
    :param scaling: Dots per mm image resolution
    :type: double
    :param filename: Filepath (relative) to save G-code to.
    :type: string
    :return:
    """

    pix_arr = np.array(pic)

    outfile = open(filename, mode='w')

    # Setup cmds
    cmds = ["; G-code autogenerated by IPS Raster block",
            "M17 ; Mots en",
            "G28 ; Home",
            "G90 ; Set abs",
            "G92 X0 Y0 ; Set current to 0 position",
            "M3 S255 ; Las on",
            "; Starting cut"]
    outfile.write("\n".join(cmds))

    for row, row_i in pix_arr, range(len(pix_arr)):
        cmds = []
        if all(row) == 255:  # If no pixels to etch, skip this row
            continue

        cmds.append("G0 X0 Y{}".format(row_i / scaling))  # Move to start of row
        last_col_i = np.where(row > 0)[0][-1]  # Only go to last non-zero column
        cmds.append("G1 X{} Y{}".format(last_col_i / scaling, row_i / scaling))
        # TODO Issue: Horizontal banding if delta_y is not larger than step size
        # TODO Truncate columns/rows for x > hman.bed_xmax

        outfile.write("\n".join(cmds))

    # Clean up commands
    cmds = []
    cmds.append("M5 ; Las off")
    cmds.append("G28 ; Home")
    cmds.append("; End IPS Raster Autogenerated G-code")
    outfile.write("\n".join(cmds))

    outfile.close()
