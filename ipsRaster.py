"""
ipsRaster.py
Image processing functions for the raster image engraving control path.

pic: actual picture
px: pixel position
pix: pixel value
"""

__author__ = 'kakit'

from PIL import Image, ImageFilter, ImageStat, ImageEnhance, ImageChops
import numpy as np


def raster_dither(in_file, scaling=10, pad=(0, 0), blackwhite=False):
    """ Convert an image to dithered greyscale, and pad it to the position
    given to ready for sending to the laser as a power/speed bitmap.

    Raises an IOError if image file could not be opened.

    :param in_file: Relative file path and name of input image
    :type: string
    :param scaling: Dots per mm setting
    :type: double
    :param pad: Set datum position of top-left of image engraving in mm
    :type: (double, double)
    :param blackwhite: Set as True if image is already black and white for
                       engraving
    :type: bool
    :return: Image converted to raster bitmap
    """
    # Get image, convert
    # Resize
    # Pad
    # Output

    # Main processing blocks, filters
    with Image.open(in_file) as pic:
        if not blackwhite:
            pic = pic.convert(mode="L")  # To greyscale

            edges = pic.filter(ImageFilter.CONTOUR)  # Pick out edges
            edges = edges.filter(ImageFilter.SMOOTH_MORE)  # Smooth edge noise

            pic = pic.filter(ImageFilter.SMOOTH_MORE)  # Smooth source noise

            # Brightness leveling for dark images
            # TODO Make a proper gamma curve thing
            brightness = ImageStat.Stat(pic).mean
            if brightness[0] < 100:
                pic = ImageEnhance.Brightness(pic).enhance(1.75)
            elif brightness[0] < 120:
                pic = ImageEnhance.Brightness(pic).enhance(1.2)

            pic = ImageChops.multiply(pic, edges)  # Recombine edges
            pic = pic.convert("1")  # Uses Floyd-Steinberg dithering by default

        # Pad out from corner
        if pad != (0, 0):
            big_pic = Image.new("1", tuple([pic.size[i] + int(pad[i] * scaling)
                                            for i in [0, 1]]), color="white")
            big_pic.paste(pic, tuple([_ * scaling for _ in pad]))
            pic = big_pic

        pic = pic.convert("L")  # Convert back to 8bit greyscale (for laser)
        return pic


def gen_gcode(filename, pic, settings):
    """ Generate a G-code file to engrave the picture, and save the text.

    Update all HardwareManager settings before generating G-code.
    Does not execute the commands, nor sets the HardwareManager las_mask.
    Uses a dictionary to maintain method signature, and requires the following
    parameters to be declared:
    # scaling: Image spacial resolution in dots/mm
    # travel_feed: Travel speed in mm/min
    # cut_feed: Lasing speed in mm/min
    # bed_xmax: Maximum x position in mm
    # bed_ymax: Maximum y position in mm

    # not enabled yet
    # setup_cmds: List of G-code commands to prefix main cutting commands (home,
    #             init, test, etc), list of strings
    # cleanup_cmds: List of G-code commands to follow main cutting commands

    Raises IOError if file could not be opened/written to.
    Raises KeyError if missing a settings dictionary value.

    :param filename: Filepath (relative) to save G-code to.
    :type: string
    :param pic: Image to engrave
    :type: PIL.Image.Image
    :param settings: Dictionary of control settings for laser hardware
    :type: dict
    :return:
    """

    # TODO There's probably a better way to take dict inputs to local vars
    scaling = settings["scaling"]
    travel_feed = settings["travel_feed"]
    cut_feed = settings["cut_feed"]
    bed_xmax = settings["bed_xmax"]
    bed_ymax = settings["bed_ymax"]
    # TODO enable setup_cmds, cleanup_cmds
    # setup_cmds = settings["setup_cmds"]
    setup_cmds = ["; G-code autogenerated by IPS Raster block",
                  "M17 ; Mots en",
                  "G28 ; Home",
                  "G90 ; Set abs",
                  "G92 X0 Y0 ; Set current to 0 position",
                  "M3 S255 ; Las on",
                  "; Starting cut"]
    # cleanup_cmds = settings["cleanup_cmds"]
    cleanup_cmds = ["M5 ; Las off",
                    "G28 ; Home",
                    "; End IPS Raster Autogenerated G-code"]

    outfile = open(filename, mode='w')
    pix_arr = np.array(pic)

    # Setup cmds
    outfile.write("\n".join(setup_cmds))

    # TODO Debug etching at different DPI than native (Doesn't do every line)
    for row_i, row in enumerate(pix_arr):
        cmds = []
        if float(row_i) / scaling > bed_ymax:  # check y limits
            continue
        if len(np.where(row < 255)[
                   0]) == 0:  # If no pixels to etch, skip this row
            continue
        # Move to start of row/first non-zero column
        first_col_i = np.where(row < 255)[0][0]
        first_col_i -= 1 if first_col_i > 0 else 0
        cmds.append("\nG0 X{} Y{} F{}".format(float(first_col_i) / scaling,
                                              float(row_i) / scaling,
                                              travel_feed))
        # Only go to last non-zero column
        last_col_i = np.where(row < 255)[0][-1]
        last_col_i += 1 if last_col_i + 1 < len(row) else 0
        if float(last_col_i) / scaling > bed_xmax:  # check x limits
            last_col_i = bed_xmax
        cmds.append("\nG1 X{} Y{} F{}".format(float(last_col_i) / scaling,
                                              float(row_i) / scaling,
                                              cut_feed))
        # TODO check horizontal banding if delta_y is not larger than step size

        outfile.writelines(cmds)

    # Clean up commands
    outfile.write("\n" + "\n".join(cleanup_cmds))

    outfile.close()
