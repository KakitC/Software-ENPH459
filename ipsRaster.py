"""
ipsRaster.py
Image processing functions for the raster image engraving control path.

pic: actual picture
px: pixel position
pix: pixel value
"""

__author__ = 'kakit'

from PIL import Image, ImageFilter, ImageStat, ImageEnhance, ImageChops
import numpy as np


def raster_dither(in_file, scaling=10, pad=(0, 0), blackwhite=False):
    """ Convert an image to dithered greyscale, and pad it to the position
    given to ready for sending to the laser as a power/speed bitmap.

    Raises an IOError if image file could not be opened.

    :param in_file: Relative file path and name of input image
    :type: string
    :param scaling: Dots per mm setting
    :type: double
    :param pad: Set datum position of top-left of image engraving in mm
    :type: (double, double)
    :param blackwhite: Set as True if image is already black and white for
                       engraving
    :type: bool
    :return: Image converted to raster bitmap
    """
    # Get image, convert
    # Resize
    # Pad
    # Output

    # Main processing blocks, filters
    with Image.open(in_file) as pic:
        if not blackwhite:
            pic = pic.convert(mode="L")  # To greyscale

            edges = pic.filter(ImageFilter.CONTOUR)  # Pick out edges
            edges = edges.filter(ImageFilter.SMOOTH_MORE)  # Smooth edge noise

            pic = pic.filter(ImageFilter.SMOOTH_MORE)  # Smooth source noise

            # Brightness leveling for dark images
            # TODO Make a proper gamma curve thing
            brightness = ImageStat.Stat(pic).mean
            if brightness[0] < 100:
                pic = ImageEnhance.Brightness(pic).enhance(1.75)
            elif brightness[0] < 120:
                pic = ImageEnhance.Brightness(pic).enhance(1.2)

            pic = ImageChops.multiply(pic, edges)  # Recombine edges
            pic = pic.convert("1")  # Uses Floyd-Steinberg dithering by default

        # Pad out from corner
        if pad != (0, 0):
            big_pic = Image.new("1", tuple([pic.size[i] + int(pad[i]*scaling)
                                            for i in [0,1]]), color="white")
            big_pic.paste(pic, tuple([_*scaling for _ in pad]))
            pic = big_pic

        pic = pic.convert("L")  # Convert back to 8bit greyscale (for laser)
        return pic


def gen_gcode(filename, pic, scaling, travel_feed, cut_feed):
    """ Generate a G-code file to engrave the picture, and save the text.

    Update all HardwareManager settings before generating G-code.
    Does not execute the commands, nor sets the HardwareManager las_mask.

    Raises IOError if file could not be opened/written to.

    :param pic: Image to engrave
    :type: PIL.Image.Image
    :param scaling: Dots per mm image resolution
    :type: double
    :param filename: Filepath (relative) to save G-code to.
    :type: string
    :param travel_feed: Travel speed in mm/min
    :type: double
    :param cut_feed: Lasing speed in mm/min
    :type: double
    :return:
    """

    pix_arr = np.array(pic)

    outfile = open(filename, mode='w')

    # Setup cmds
    cmds = ["\n; G-code autogenerated by IPS Raster block",
            "M17 ; Mots en",
            "G28 ; Home",
            "G90 ; Set abs",
            "G92 X0 Y0 ; Set current to 0 position",
            "M3 S255 ; Las on",
            "; Starting cut"]
    outfile.write("\n".join(cmds))

    for row_i, row in enumerate(pix_arr):
        cmds = []
        if len(np.where(row < 255)[0]) == 0:  # If no pixels to etch, skip this row
            continue
        # Move to start of row/first non-zero column
        first_col_i = np.where(row < 255)[0][0]
        first_col_i -= 1 if first_col_i > 0 else 0
        cmds.append("\nG0 X{} Y{} F{}".format(float(first_col_i) / scaling,
                                              float(row_i) / scaling,
                                              travel_feed))
        # Only go to last non-zero column
        last_col_i = np.where(row < 255)[0][-1]
        cmds.append("\nG1 X{} Y{} F{}".format(float(last_col_i) / scaling,
                                              float(row_i) / scaling,
                                              cut_feed))
        # TODO Issue: Horizontal banding if delta_y is not larger than step size
        # TODO Truncate columns/rows for x > hman.bed_xmax

        outfile.writelines(cmds)

    # Clean up commands
    cmds = ["\nM5 ; Las off",
            "G28 ; Home",
            "; End IPS Raster Autogenerated G-code"]
    outfile.write("\n".join(cmds))

    outfile.close()
